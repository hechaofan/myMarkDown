引用地址：

https://github.com/attackonryan/Professional-JavaScript-for-Web-Developers-4th-Edition-reading-notes/blame/master/Chapter6.md

 

# 第六章：集合引用类型

## 6.1 Object

Object是ECMAScript中最常用的类型之一。

创建Object有两种方式，一种是使用new操作符和Object构造函数，另一种方式是使用**对象字面量**表示法（object literal）

```
let person = new Object()
person.name = 'Ryan'

// 对象字面量表示
let person2 = {
    name: 'Titan'
}         
```

字符串的属性名可以是字符串或数值，数值属性会自动转换为字符串

```
let person = {
    "name": "Ryan",
    age: 20,
    5: true
}
```

使用中括号可以通过变量访问属性，或设置属性。

```
let option = 'name'

let person = {
    [option]: 'Ryan'
}

person[option] = 'AttackonRyan'
```

通常，点语法是首选的属性存取方式，除非访问属性时必须使用变量。



### js高效修改对象里的对象属性名

```
JSON.parse(JSON.stringify(data).replace(/name1/g, 'new_name1').replace(/name2/g, 'new_name2').replace(/name3/g, 'new_name'))
```



## 6.2 Array

ECMAScript中的数组是一组有序的数据，且每个槽位可以存储任意类型的数据。

ECMAScript中的数组也是动态大小的，会随着数据的添加而自动增长。

### 6.2.1 创建数组

有几种基本方式创建数组。一种是使用Array构造函数，给构造函数传入一个数值，然后length属性就会被自动创建并设置为这个值。

```
let colors = new Array(20)    // 创建一个初始length为20的数组
```

也可以给Array构造函数传入要保存的元素。比如下面的代码会创建一个包含3个字符串值的数组。

```
let colors = new Array("red", "blue", "green")
```

有时候想创建一个只含一个数字的数组，直接使用Array构造函数是办不到的，因为他会创建一个长度为传入的数值的数组。这时候可以使用Array.of()方法（ES6新增），这个方法用于将一组参数转换为数组实例。

```
let colors = new Array(20)    // [empty × 20] 创建了一个初始length为20的数组
let nums = Array.of(20)       // [20]
```

另一种创建数组的方式是使用**数组字面量**（array literal）表示法。

```
let colors = ["red", "blue", "green"]
```

Array.from()也可以创建数组，用于将类数组结构转换为数组实例。

Array.from()的第一个参数是一个类数组对象，即任何可迭代的结构，或者有一个length属性和可索引元素的结构。

```
// 字符串会被拆分成单字符串数组
console.log(Array.from("Ryan"))  // ["R", "y", "a", "n"]

// Array.from()对现有数组执行浅复制
const a1 = [1, 2, 3, 4]
const a2 = Array.from(a1)

console.log(a1)      // [1, 2, 3, 4]
console.log(a1 === a2)  // false

// arguments对象可以被轻松地转换为数组
function getArgsArray(){
    return Array.from(arguments)
}
console.log(getArgsArray(1, 2, 3))   // [1, 2, 3]

// from()也能转换带有必要属性的自定义对象
const arrayLikeObject = {
    0: 1,
    1: 2,
    2: 3,
    3: 4,
    length: 4
}
console.log(Array.from(arrayLikeObject))   // [1, 2, 3, 4]
```

Array.from()还接收第二个可选的映射函数参数。这个函数可以改写新数组的值。还可以接收第三个可选参数，用于指定映射函数中this的值。

```
const a1 = [1, 2, 3, 4]
const a2 = Array.from(a1, x => x  2)
const a3 = Array.from(a1, function(x){ 
    return x  this.exponent
}, {
    exponent: 2
})

console.log(a2)   // [1, 4, 9, 16]
console.log(a3)   // [1, 4, 9, 16]
```

### 6.2.2 数组空位

使用数组字面量初始化数组时，可以使用一串逗号来创建空位（hole）。ECMAScript会将逗号之间相应索引位置的值当成空位，ES6规范重新定义了该如何处理这些空位。

```
const options = [,,,,,]    //创建包含5个元素的数组
console.log(options.length)   // 5
console.log(options)    // [,,,,,]
```

for-of循环会将空位当成存在的元素，只不过值为**undefined**。

ES6之前的方法则会忽略这个空位，但具体的行为也会因方法而异。

> 注意：由于行为不一致和存在性能隐患，实践中要避免使用数组空位。如确实需要空位，则可以显示地用undefined代替

### 6.2.3 数组索引

要取得或设置数组的值，需要使用中括号并提供相应值的数字索引：

```
let colors = ["red", "blue", "green"]
colors[2] = "black"   // 修改第三项
```

如果把一个值设置给超过数组最大索引的索引，则数组长度会自动扩展到该索引值加1

```
let colors = ["red", "blue", "green"]
colors[5] = "black"   // 设置第6项为"black"
console.log(colors.length)   // 6
```

通过修改length属性，可以截断或增长数组。增长数组后多出来的空位由**undefined**填充。

```
let colors = ["red", "blue", "green"]
colors.length = 1
console.log(colors)   // ["red"]

colors.length = 4
console.log(colors[3]) // undefined 
```

### 6.2.4 检测数组

**instanceof** 操作符可以检测一个对象是不是数组。

```
if(value instanceof Array){
   // 操作数组 
}
```

但是如果网页里存在多个框架，可能会涉及两个不同的全局执行上下文，因此会有两个不同版本的Array构造函数，这个时候**instanceof**不一定返回正确的结果。

为解决这个问题，ECMAScript提供了**Array.isArray**()方法。这个方法的目的是确定一个值是否为数组，而不用管它在哪个全局执行上下文中创建的。

```
if(Array.isArray(value)){
    // 操作数组
}
```

### 6.2.5 迭代器方法

ES6中，Array的原型上暴露了3个用于检索数组内容的方法：**keys**()、**values**()和**entries**()。

**keys**()返回数组索引的迭代器，**values**()返回数组元素的迭代器、而**entries**()返回索引/值对的迭代器。

```
const a = ["foo", "bar", "baz", "qux"]

// 因为这些方法都返回迭代器，所以可以将它们的内容通过Array.from()直接转换为数组实例
const aKeys = Array.from(a.keys())
const aValues = Array.from(a.balues())
const aEntries = Array.from(a.entries())

console.log(aKeys)      // [0, 1, 2, 3]
console.log(aValues)    // ["foo", "bar", "baz", "qux"]
console.log(aEntries)   // [[0, "foo"], [1, "bar"], [2, "baz"], [3, "qux"]]
```

### 6.2.6 复制和填充方法

ES6新增了两个方法：批量赋值方法**fill**()，以及填充数组方法**copyWithin**()。

**fill**()的第一个参数是填充的值，第二个可选参数是索引的开始。第三个可选参数的索引的结束。

```
const zeroes = [0, 0, 0, 0, 0]

zeroes.fill(7, 1, 3) 

console.log(zeroes)  // [0, 7, 7, 0, 0]
```

**copyWithin**()会按照指定范围浅复制数组中的部分内容，然后插入到指定索引开始位置。第一个参数是索引开始位置，第二，第三个参数是指定范围的开始索引和结束索引。

```
const numbers = [1,2,3,4,5,6]

numbers.copyWithin(2, 4, 6)

console.log(numbers)  // [1, 2, 5, 6, 5, 6]
```

### 6.2.7 转换方法

所有对象都有**toLocaleString**()、**toString**()和**valueOf**()方法。

其中**valueOf**()返回的还是数组本身。

**toString**()返回由数组中每个值调用**toString**()返回的字符串拼接而成的一个逗号分隔的字符串。

**toLocaleString**()方法类似**toString**()，取数组每个元素值的时候会调用**toLocaleString**()方法，返回字符串拼接而成的一个逗号分隔的字符串。

```
let colors = ["red", "blue", "green"]
console.log(colors.toString())   // "red,blue,green"
```

调用数组上的**join**()方法也可以获取字符串，不传参的情况下与**toString**()的返回值相同，如果传了参数，则分隔符变为参数。

```
let colors = ["red", "blue", "green"]
console.log(colors.join(","))  // "red,green,blue"
console.log(colors.join("||")) // "red||green||blue"
```

### 6.2.8 栈方法

ECMAScript数组提供了**push**()和**pop**()方法，以实现类似栈的行为。

**push**()方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度。

**pop**()方法则用于删除数组的最后一项，同时减少数组的length值，返回被删除的项。

### 6.2.9 队列方法

使用**shift**()和**push**()方法，可以把数组当成队列来使用。

**shift**()方法会删除数组的第一项并返回它。

ECMAScript也提供了**unshift**()方法，这个方法执行**shift**()相反的操作：在数组开头添加任意多个值，然后返回新的数组长度。

### 6.2.10 排序方法

数组有两种方法可以用来对元素重新排序：reverse()和sort()。

**reverse**()方法将数组元素反向 排列。

```
let values = [1, 2, 3, 4, 5]
values.reverse()
console.log(values)  // [5, 4, 3, 2, 1]
```

**sort**()方法用于排序数组，默认情况下会按照升序排序，最小的值在前面，最大的值在后面。为此**sort**()会在每一项上调用String()转型函数，然后来比较字符串决定顺序。

```
let values = [0, 1, 5, 10, 15]
values.sort()
console.log(values) // [0, 1, 10, 15 ,5]     // "5" > "15"
```

**sort**()方法接收一个比较函数，用于判断哪个值应该排在前面。

比较函数接收两个参数，如果第一个参数应该排在第二个参数前面，则函数返回负值。如果第一个参数应该排在第二个参数后面，则返回正值。如果参数不用变化位置，则返回0。

```
function compare(v1, v2){
    if(v1 < v2){
        return -1
    }else if(v1 > v2){
        return 1
    }else{
        return 0
    }
}
/*
	等价
	function compare(v1, v2){
		return v1 - v2
	}
*/

let values = [0, 1, 15, 10, 5]
values.sort(compare)
console.log(values)  // [0, 1, 5, 10, 15]
```

### 6.2.11 操作方法

对于数组中的元素，我们有很多操作方法。接下来讲三种方法：**concat**()、**slice**()、**splice**()

**concat**()方法可以在现有数组全部元素基础上创建一个新的数组。它首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组。如果参数是一个或多个数组，**concat**()会把数组的每一项添加到结果数组。

```
let colors = ["red", "green", "blue"]
let colors2 = colors.concat("yellow", ["black", "brown"])

console.log(colors2)  // ["red", "green", "blue", "yellow", "black", "brown"]
```

**slice**()方法用于创建一个包含原始数组中一个或多个元素的新数组。**slice**()方法可以接收一个或两个参数：返回元素的开始索引和结束索引(不包含)，不过不提供第二个参数，则默认从开始索引取到末尾。

```
let colors = ["red", "green", "blue"]
let colors2 = colors.slice(1)
let colors3 = colors.slice(1,2)
console.log(colors2)   // ["green", "blue"]
console.log(colors3)   // ["green"]
```

**splice**()方法可以改变数组本身。它接收三个参数，第一个参数指定删除元素的开始位置，第二个参数指定删除元素的数量，第三个以及之后的参数指定在开始位置处要插入的元素。

```
let colors = ["red", "green", "blue"]
let removed = colors.splice(0, 1)    // 在位置0处删除1个元素
console.log(removed)    // "red"
console.log(colors)     // ["green", "blue"]

colors.splice(1, 0 ,"a", "b")    // 在位置1处删除0个元素，并插入两个元素
console.log(colors)    // ["green", "a", "b", "blue"]
```

### 6.2.12 搜索和位置方法

ECMAScript提供两类搜索数组的方法：按严格相等搜索和按断言函数搜索。

#### 1. 严格相等

ECMAScript提供了3个严格相等的搜索方法：**indexOf**()、**lastIndexOf**()和**includes**()（ES7）。

这三个方法都接收两个参数：要查找的元素和一个可选的起始搜索位置。

**indexOf**()和**includes**()方法从数组前头开始向后搜索，而**lastIndexOf**()方法相反。

**indexOf**()和**lastIndexOf**()返回查找的元素在数组中的位置，如果没找到则返回-1.

**includes**()返回布尔值，表示是否找到一个指定元素匹配的项。

三个方法在比较时会使用全等（===）比较。

```
let numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1]

console.log(numbers.indexOf(4))     // 3
console.log(numbers.lastIndexOf(4)) // 5
console.log(numbers.includes(4))    // true

console.log(numbers.indexOf(4, 4))     // 5
console.log(numbers.lastIndexOf(4, 4)) // 3
console.log(numbers.includes(4, 7))    // false
```

#### 2. 断言函数

ECMAScript也允许按照定义的断言函数搜索数组，每个索引都会调用这个函数。

断言函数接收3个参数：**元素、索引和数组本身**。元素指的是数组中当前搜索的元素。

**find**()和**findIndex**()方法使用了断言函数。find()返回第一个匹配的元素，**findIndex**()返回第一个匹配元素的索引。

```
let nums = [5, 4, 2, 10]
let tenIndex = nums.findIndex(function(v, i, arr){
  return v === 10  
})

console.log(tenIndex)    // 3
```

### 6.2.13 迭代方法

ECMAScript为数组定义了5个迭代方法。每个方法接收两个参数：以每一项为参数运行的函数、以及可选的作为函数运行上下文的作用域对象（影响函数中this的值）。传给每个方法的函数接收3个参数：**数组元素、元素索引和数组本身**。这5个迭代方法如下：

- every()：对数组每一项都运行传入的函数，如果对每一项都返回true，则这个方法返回true。
- filter()：对数组每一项都运行传入的函数，函数返回true的项会组成数组之后返回。
- forEach()：对数组每一项都运行传入的函数，无返回值。
- map()：对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组。
- some()：对数组每一项都运行传入的函数，如果有一项函数返回true，则这个方法返回true，否则返回false

```
let numbers = [1, 2, 3, 4]
let newNums = numbers.map(function(v, i, arr){
    return v  2
})
console.log(newNums)    // [2, 4, 6, 8]
```

### 6.2.14 归并方法

ECMAScript为数组提供了两个归并方法：**reduce**()和**reduceRight**()。

这两个方法接收两个参数：第一个参数为初始值，第二个为当前值。每轮循环的返回值都会作为下轮循环的初始值，最后一轮循环的返回值即最终的返回值。

```
let values = [1, 2, 3, 4]
let sum = values.reduce(function(pre, cur){
    // 第一次循环，pre为1，cur为2
    return pre + cur
})
console.log(sum)   // 10
```

如果不提供第二个参数，则默认第一次初始值为第一个元素，当前值则为第二个元素。

如果提供第二个参数，则默认第一次循环的初始值为第二个参数，当前值为第一个元素。

```
let values = [1, 2, 3, 4]
let sum = values.reduce(function(pre, cur){
    // 第一次循环，pre为0，cur为1
    return pre + cur
}, 0)
console.log(sum)   // 10
```

**reduceRight**()和**reduce**()方法的差别只是方向相反一下。





### js的四种for循环

作者：北极北链接：https://juejin.cn/post/6844903513336610823

#### **简单 for 循环**

下面先来看看大家最常见的一种写法：

```
const arr = [1, 2, 3];
for(let i = 0; i　< arr.length; i++) {
    console.log(arr[i]);
}复制代码
```

当数组长度在循环过程中不会改变时，我们应将数组长度用变量存储起来，这样会获得更好的效率，下面是改进的写法：

```
const arr = [1, 2, 3];
for(let i = 0, len = arr.length; i < len; i++) {
    console.log(arr[i]);
}
```

for in 和 for of 相对于大家肯定都不陌生,都是用来遍历属性的没错。那么先看下面的一个例子:

例1



```jsx
    const obj = {
        a: 1,
        b: 2,
        c: 3
    }
    for (let i in obj) {
        console.log(i)
        // a
        // b
        // c
    }
    for (let i of obj) {
        console.log(i)
        // Uncaught TypeError: obj is not iterable 报错了
    }
```

以上代码通过 for in 和 for of 对一个obj对象进行遍历,for in 正常的获取了对象的 key值,分别打印 a、b、c,而 for of却报错了。

例2:

以上是遍历对象,下面再看一个遍历数组的例子。



```jsx
    const arr = ['a', 'b', 'c']
    // for in 循环
    for (let i in arr) {
        console.log(i)
        // 0
        // 1
        // 2
    }

    // for of
    for (let i of arr) {
        console.log(i)
        // a
        // b
        // c
    }
```

以上代码是对一个数组进行遍历, for in 返回的值为 0、1、2,这不是数组的下标吗? 而 for of 返回的是 a、b、c,这一次没有报错,为什么呢?

例3



```jsx
    const arr = ['a', 'b']
    // 手动给 arr数组添加一个属性
    arr.name = 'qiqingfu'

    // for in 循环可以遍历出 name 这个键名
    for (let i in arr) {
        console.log(i)
        // 0
        //1
        // name
    }
```

#### **for in 的特点**

结合上面的两个例子,分析得出:

- for ... in 循环返回的值都是数据结构的 **键值名**。
   遍历对象返回的对象的key值,遍历数组返回的数组的下标(key)。
- for ... in 循环不仅可以遍历数字键名,还会遍历原型上的值和手动添加的其他键。如——**例3**
- 特别情况下, for ... in 循环会以任意的顺序遍历键名

> 总结一句: **for in** 循环特别适合遍历对象。

#### **for of 特点**

- for of 循环用来获取一对键值对中的值,而 for in 获取的是 键名

- 一个数据结构只要部署了 Symbol.iterator 属性, 就被视为具有 iterator接口, 就可以使用 for of循环。

  例1这个对象,没有 Symbol.iterator这个属性,所以使用 for of会报 obj is not iterable

- for of 不同与 forEach, 它可以与 break、continue和return 配合使用,也就是说 for of 循环可以随时退出循环。

- 提供了遍历所有数据结构的统一接口

**哪些数据结构部署了 Symbol.iteratoer属性了呢?**

只要有 iterator 接口的数据结构,都可以使用 for of循环。

- 数组 Array
- Map
- Set
- String
- arguments对象
- Nodelist对象, 就是获取的dom列表集合

以上这些都可以直接使用 for of 循环。 凡是部署了 iterator 接口的数据结构也都可以使用数组的 扩展运算符(...)、和解构赋值等操作。

我也想让对象可以使用 for of循环怎么办?使用 Object.keys() 获取对象的 key值集合后,再使用 for of

以例1为例



```jsx
    const obj = {
        a: 1,
        b: 2,
        c: 3
    }

    for (let i of Object.keys(obj)) {
        console.log(i)
        // a
        // b
        // c
    }
```

也可以给一个对象部署 Symbol.iterator属性。



#### forEach



#### JavaScript -- forEach不能改变原数组的的问题

引用 https://www.jianshu.com/p/fd8c841ce5aa

forEach是没有返回值并且不直接改变原数组的，今天发现是不能直接改变，用些技巧是可以间接改变的。

1. forEach(item, index, arr)，三个参数，如果直接用item=xxx是无法改变原数组的，但是如果用arr[index]就可以改变原数组。



```ruby
var s = [1,2,3,4];
s.forEach(item=>{
   item = 'a'
});
console.log(s);// ["1", "2", "3", "4"] 未改变原数组


s.forEach((item, index, arr)=>{
   arr[index] = 'b'
});
console.log(s);// ["b", "b", "b", "b"] 改变了原数组
```

1. 数组里面的子元素是对象，那么是可以改变对应属性的



```jsx
var s = [{a:1}, {a:1}];
s.forEach(item=>{
    item = null;
});
console.log(s);//[{a: 1} ,{a: 1}] 未改变原数组
 
s.forEach(item=>{
    item.a = 666;
});
console.log(s); // [{a: 666}, {a: 666}] //改变的原数组里面的对象属性
```















## 6.3 定型数组（typed array）

暂时跳过。

## 6.4 Map

作为ECMAScript的新增特性，Map是一种新的集合类型，为这门语言带来了真正的键/值存储机制。Map的大多数特性都可以通过Object类型实现，但二者之间还是存在一些细微的差别。

### 6.4.1 基本API

使用new关键字和Map构造函数可以创建一个空映射：

```
const m = new Map()
```

如果想在创建的同时初始化实例，可以给Map构造函数传入一个可迭代对象，需要包含键/值对数组。

```
const m1 = new Map([
    ["key1", "val1"],
    ["key2", "val2"],
    ["key3", "val3"]
])

console.log(m1.size)  // 3
```

可以使用**set**()方法添加键/值对。可以使用**get**()和**has**()进行查询，可以通过**size**属性获取映射中的键/值对的数量。使用**delete**()和**clear**()删除值。

```
const m = new Map()

console.log(m.has("name"))   // false
console.log(m,size)          // 0

m.set("name", "Ryan")

console.log(m.has("name"))   // true
console.log(m.get("name"))   // "Ryan"

m.delete("name")
console.log(m.size)          // 0 
```

> Map内部使用**SameValueZero**比较操作，NaN与NaN认为是同一个值，-0 与 +0也认为是一个值。

### 6.4.2 顺序与迭代

Map的默认迭代器返回**entries**()（或者Symbol.iterator属性，它引用**entries**()）方法取得的值，也就是以插入顺序生成[key, value]形式的数组。

```
const m1 = new Map([
    ["key1", "val1"],
    ["key2", "val2"],
    ["key3", "val3"]
])

for(let pair of m1){
    console.log(pair)
}

// ["key1", "val1"]
// ["key2", "val2"]
// ["key3", "val3"]
```

**keys**()和**values**()分别返回以插入顺序生成键和值的迭代器。

```
const m1 = new Map([
    ["key1", "val1"],
    ["key2", "val2"],
    ["key3", "val3"]
])

for(let key of m1.keys()){
    console.log(key)
}

// "key1"
// "key2"
// "key3"

for(let value of m1.values()){
    console.log(value)
}

// "val1"
// "val2"
// "val3"
```

### 6.4.3 选择object还是Map

如果代码涉及大量删除操作，选择Map，其它情况，Map与object差距不大，一般来说Map内存占用更少。

## 6.5 WeakMap

ECMAScript6新增的“弱映射”（WeakMap）是一种新的集合类型，为这门语言带来了增强的键/值对存储机制。WeakMap是Map的“兄弟”类型，其API也是Map的子集。WeakMap中的“weak”（弱），描述的是JavaScript垃圾回收程序对待“弱映射”中键的方式。

### 6.5.1 基本API

使用new关键字实例化一个空的WeakMap:

```
const wm = new WeakMap()
```

弱映射中的键只能是Object或者继承自Object的类型，尝试使用非对象设置键会抛出TypeError。值的类型没有限制。

```
const wm = new WeakMap()

let obj = {}
console.log(wm.has(obj))   // false

wm.set(obj, "Ryan")

console.log(wm.has(obj))   // true
console.log(wm.get(obj))   // "Ryan"

m.delete(obj)
```

### 6.5.2 弱键

**WeakMap中的键不属于正式的引用，不会阻止垃圾回收**。

### 6.5.3 不可迭代键

因为WeakMap中的键/值对任何时候都可能被销毁，**所以没必要提供迭代其键/值对的能力**。所以WeakMap不提供clear()这样一次性销毁所有键/值的方法。

## 6.6 Set

ECMAScript6新增的Set是一种新集合类型。Set在很多方面都像是加强的Map，这是因为它们的大多数API和行为都是共有的。

### 6.6.1 基本API

使用new关键字和Set构造函数创建一个空集合：

```
const m = new Set()
```

可以给构造函数传入一个可迭代对象来初始化实例：

```
const s1 = new Set(["val1", "val2", "val3"])
console.log(s1.size)   // 3
```

初始化之后，可以使用**add**()增加值，使用**has**()查询，通过**size**取得元素数量，以及使用**delete**()和**clear**()删除元素。

```
const s1 = new Set(["val1", "val2", "val3"])
console.log(s1.size)   // 3
s1.add("val4")
s1.delete("val1")

console.log(s1)    // ["val2", "val3", "val4"]
```

Set可以包含任何值，但不允许出现重复的值，集合与Map类似，使用**SameValueZero**操作（NaN与NaN认为是同一个值，-0 与 +0也认为是一个值）。

```
const s1 = new Set(["val1", "val2", "val3"])
s1.add("val3")

console.log(s1)    // ["val1", "val2", "val3"]
```

### 6.6.2 顺序与迭代

集合实例可以通过**values**()方法及其别名方法**keys**()（或者Symbol.iterator属性，它引用**values**()）取得迭代器（Iterator）：

```
const s1 = new Set(["val1", "val2", "val3"])

console.log(s.values === s[Symbol.iterator])   // true
console.log(s.keys === s[Symbol.iterator])   // true

for(let value of s.values()){
    console.log(value)
}
// "val1"
// "val2"
// "val3"

for(let value of s[Symbol.iterator]()){
    console.log(value)
}
// "val1"
// "val2"
// "val3"
```

集合的**entries**()方法返回一个迭代器，可以按照插入顺序产生包含两个元素的数组，这两个元素是集合中每个值的重复出现：

```
for(let pair of s.entries()){
    console.log(pair)
}
// ["val1", "val1"]
// ["val2", "val2"]
// ["val3", "val3"]
```

## 6.7 WeakSet

WeakSet是Set的“兄弟”类型，其API也是Set的子集。

### 6.7.1 基本API

可以使用new关键字实例化一个空的WeakSet：

```
const ws = new WeakSet()
```

**弱集合中的值只能是Object或者继承自Object的类型，尝试使用非对象设置值会抛出TypeError**。

```
const val1 = {id:1}
const val2 = {id:2}

const ws = new WeakSet([val1])

ws.has(val2)    // false
ws.add(val2)
ws.has(val2)    // true
```

### 6.7.2 弱值

**WeakSet中的值不属于正式的引用，不会阻止垃圾回收**。

### 6.7.3 不可迭代值

因为WeakSet中的值任何时候都可能被销毁，所以没必要提供迭代其值的能力，因此同样用不着像**clear**()这样一次性销毁所有值的方法。



## keys，values，entries

它们支持：

- `Map`
- `Set`
- `Array`



## Object.keys，values，entries

对于普通对象，下列这些方法是可用的：

- [Object.keys(obj)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/keys) —— 返回一个包含该对象所有的键的数组。
- [Object.values(obj)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/values) —— 返回一个包含该对象所有的值的数组。
- [Object.entries(obj)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/entries) —— 返回一个包含该对象所有 [key, value] 键值对的数组。

……但是请注意区别（比如说跟 map 的区别）：

|          | Map          | Object                                  |
| :------- | :----------- | :-------------------------------------- |
| 调用语法 | `map.keys()` | `Object.keys(obj)`，而不是 `obj.keys()` |
| 返回值   | 可迭代项     | “真正的”数组                            |

第一个区别是，对于对象我们使用的调用语法是 `Object.keys(obj)`，而不是 `obj.keys()`。

为什么会这样？主要原因是灵活性。请记住，在 JavaScript 中，对象是所有复杂结构的基础。因此，我们可能有一个自己创建的对象，比如 `data`，并实现了它自己的 `data.values()` 方法。同时，我们依然可以对它调用 `Object.values(data)` 方法。

第二个区别是 `Object.*` 方法返回的是“真正的”数组对象，而不只是一个可迭代项。这主要是历史原因。

举个例子：

```
let user = {  name: "John",  age: 30};
```

- `Object.keys(user) = ["name", "age"]`
- `Object.values(user) = ["John", 30]`
- `Object.entries(user) = [ ["name","John"], ["age",30] ]`

这里有一个使用 `Object.values` 来遍历属性值的例子：

```
let user = {  name: "John",  age: 30};// 遍历所有的值
for (let value of Object.values(user)) 
	{  alert(value); // John, then 30}
```

Object.keys/values/entries 会忽略 symbol 属性

就像 `for..in` 循环一样，这些方法会忽略使用 `Symbol(...)` 作为键的属性。

通常这很方便。但是，如果我们也想要 Symbol 类型的键，那么这儿有一个单独的方法 [Object.getOwnPropertySymbols](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols)，它会返回一个只包含 Symbol 类型的键的数组。另外，还有一种方法 [Reflect.ownKeys(obj)](https://developer.mozilla.org/zh/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys)，它会返回 **所有** 键。

## 转换对象

对象缺少数组存在的许多方法，例如 `map` 和 `filter` 等。

如果我们想应用它们，那么我们可以在 `Object.entries` 之后使用 `Object.fromEntries`：

1. 使用 `Object.entries(obj)` 从 `obj` 获取由键/值对组成的数组。
2. 对该数组使用数组方法，例如 `map`。
3. 对结果数组使用 `Object.fromEntries(array)` 方法，将结果转回成对象。

例如，我们有一个带有价格的对象，并想将它们加倍：

```
 复制代码let prices = {  banana: 1,  orange: 2,  meat: 4,};let doublePrices = Object.fromEntries(  // 转换为数组，之后使用 map 方法，然后通过 fromEntries 再转回到对象  Object.entries(prices).map(([key, value]) => [key, value * 2]));alert(doublePrices.meat); // 8
```







































引用：

https://es6.ruanyifeng.com/#docs/set-map

# Set 和 Map 数据结构

1. [Set](https://es6.ruanyifeng.com/#docs/set-map#Set)
2. [WeakSet](https://es6.ruanyifeng.com/#docs/set-map#WeakSet)
3. [Map](https://es6.ruanyifeng.com/#docs/set-map#Map)
4. [WeakMap](https://es6.ruanyifeng.com/#docs/set-map#WeakMap)

## Set

### 基本用法

ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。

`Set`本身是一个构造函数，用来生成 Set 数据结构。

```javascript
const s = new Set();

[2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));

for (let i of s) {
  console.log(i);
}
// 2 3 5 4
```

上面代码通过`add()`方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。

`Set`函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。

```javascript
// 例一
const set = new Set([1, 2, 3, 4, 4]);
[...set]
// [1, 2, 3, 4]

// 例二
const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);
items.size // 5

// 例三
const set = new Set(document.querySelectorAll('div'));
set.size // 56

// 类似于
const set = new Set();
document
 .querySelectorAll('div')
 .forEach(div => set.add(div));
set.size // 56
```

上面代码中，例一和例二都是`Set`函数接受数组作为参数，例三是接受类似数组的对象作为参数。

上面代码也展示了一种去除数组重复成员的方法。

```javascript
// 去除数组的重复成员
[...new Set(array)]
```

上面的方法也可以用于，去除字符串里面的重复字符。

```javascript
[...new Set('ababbc')].join('')
// "abc"
```

向 Set 加入值的时候，不会发生类型转换，所以`5`和`"5"`是两个不同的值。Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（`===`），主要的区别是向 Set 加入值时认为`NaN`等于自身，而精确相等运算符认为`NaN`不等于自身。

```javascript
let set = new Set();
let a = NaN;
let b = NaN;
set.add(a);
set.add(b);
set // Set {NaN}
```

上面代码向 Set 实例添加了两次`NaN`，但是只会加入一个。这表明，在 Set 内部，两个`NaN`是相等的。

另外，两个对象总是不相等的。

```javascript
let set = new Set();

set.add({});
set.size // 1

set.add({});
set.size // 2
```

上面代码表示，由于两个空对象不相等，所以它们被视为两个值。

### Set 实例的属性和方法

Set 结构的实例有以下属性。

- `Set.prototype.constructor`：构造函数，默认就是`Set`函数。
- `Set.prototype.size`：返回`Set`实例的成员总数。

Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。

- `Set.prototype.add(value)`：添加某个值，返回 Set 结构本身。
- `Set.prototype.delete(value)`：删除某个值，返回一个布尔值，表示删除是否成功。
- `Set.prototype.has(value)`：返回一个布尔值，表示该值是否为`Set`的成员。
- `Set.prototype.clear()`：清除所有成员，没有返回值。

上面这些属性和方法的实例如下。

```javascript
s.add(1).add(2).add(2);
// 注意2被加入了两次

s.size // 2

s.has(1) // true
s.has(2) // true
s.has(3) // false

s.delete(2);
s.has(2) // false
```

下面是一个对比，看看在判断是否包括一个键上面，`Object`结构和`Set`结构的写法不同。

```javascript
// 对象的写法
const properties = {
  'width': 1,
  'height': 1
};

if (properties[someName]) {
  // do something
}

// Set的写法
const properties = new Set();

properties.add('width');
properties.add('height');

if (properties.has(someName)) {
  // do something
}
```

`Array.from`方法可以将 Set 结构转为数组。

```javascript
const items = new Set([1, 2, 3, 4, 5]);
const array = Array.from(items);
```

这就提供了去除数组重复成员的另一种方法。

```javascript
function dedupe(array) {
  return Array.from(new Set(array));
}

dedupe([1, 1, 2, 3]) // [1, 2, 3]
```

### 遍历操作

Set 结构的实例有四个遍历方法，可以用于遍历成员。

- `Set.prototype.keys()`：返回键名的遍历器
- `Set.prototype.values()`：返回键值的遍历器
- `Set.prototype.entries()`：返回键值对的遍历器
- `Set.prototype.forEach()`：使用回调函数遍历每个成员

需要特别指出的是，`Set`的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。

**（1）`keys()`，`values()`，`entries()`**

`keys`方法、`values`方法、`entries`方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以`keys`方法和`values`方法的行为完全一致。

```javascript
let set = new Set(['red', 'green', 'blue']);

for (let item of set.keys()) {
  console.log(item);
}
// red
// green
// blue

for (let item of set.values()) {
  console.log(item);
}
// red
// green
// blue

for (let item of set.entries()) {
  console.log(item);
}
// ["red", "red"]
// ["green", "green"]
// ["blue", "blue"]
```

上面代码中，`entries`方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。

Set 结构的实例默认可遍历，它的默认遍历器生成函数就是它的`values`方法。

```javascript
Set.prototype[Symbol.iterator] === Set.prototype.values
// true
```

这意味着，可以省略`values`方法，直接用`for...of`循环遍历 Set。

```javascript
let set = new Set(['red', 'green', 'blue']);

for (let x of set) {
  console.log(x);
}
// red
// green
// blue
```

**（2）`forEach()`**

Set 结构的实例与数组一样，也拥有`forEach`方法，用于对每个成员执行某种操作，没有返回值。

```javascript
let set = new Set([1, 4, 9]);
set.forEach((value, key) => console.log(key + ' : ' + value))
// 1 : 1
// 4 : 4
// 9 : 9
```

上面代码说明，`forEach`方法的参数就是一个处理函数。该函数的参数与数组的`forEach`一致，依次为键值、键名、集合本身（上例省略了该参数）。这里需要注意，Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。

另外，`forEach`方法还可以有第二个参数，表示绑定处理函数内部的`this`对象。

**（3）遍历的应用**

扩展运算符（`...`）内部使用`for...of`循环，所以也可以用于 Set 结构。

```javascript
let set = new Set(['red', 'green', 'blue']);
let arr = [...set];
// ['red', 'green', 'blue']
```

扩展运算符和 Set 结构相结合，就可以去除数组的重复成员。

```javascript
let arr = [3, 5, 2, 2, 5, 5];
let unique = [...new Set(arr)];
// [3, 5, 2]
```

而且，数组的`map`和`filter`方法也可以间接用于 Set 了。

```javascript
let set = new Set([1, 2, 3]);
set = new Set([...set].map(x => x * 2));
// 返回Set结构：{2, 4, 6}

let set = new Set([1, 2, 3, 4, 5]);
set = new Set([...set].filter(x => (x % 2) == 0));
// 返回Set结构：{2, 4}
```

因此使用 Set 可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。

```javascript
let a = new Set([1, 2, 3]);
let b = new Set([4, 3, 2]);

// 并集
let union = new Set([...a, ...b]);
// Set {1, 2, 3, 4}

// 交集
let intersect = new Set([...a].filter(x => b.has(x)));
// set {2, 3}

// （a 相对于 b 的）差集
let difference = new Set([...a].filter(x => !b.has(x)));
// Set {1}
```

如果想在遍历操作中，同步改变原来的 Set 结构，目前没有直接的方法，但有两种变通方法。一种是利用原 Set 结构映射出一个新的结构，然后赋值给原来的 Set 结构；另一种是利用`Array.from`方法。

```javascript
// 方法一
let set = new Set([1, 2, 3]);
set = new Set([...set].map(val => val * 2));
// set的值是2, 4, 6

// 方法二
let set = new Set([1, 2, 3]);
set = new Set(Array.from(set, val => val * 2));
// set的值是2, 4, 6
```

上面代码提供了两种方法，直接在遍历操作中改变原来的 Set 结构。

## WeakSet

### 含义

WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。

首先，WeakSet 的成员只能是对象，而不能是其他类型的值。

```javascript
const ws = new WeakSet();
ws.add(1)
// TypeError: Invalid value used in weak set
ws.add(Symbol())
// TypeError: invalid value used in weak set
```

上面代码试图向 WeakSet 添加一个数值和`Symbol`值，结果报错，因为 WeakSet 只能放置对象。

其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。

这是因为垃圾回收机制依赖引用计数，如果一个值的引用次数不为`0`，垃圾回收机制就不会释放这块内存。结束使用该值之后，有时会忘记取消引用，导致内存无法释放，进而可能会引发内存泄漏。WeakSet 里面的引用，都不计入垃圾回收机制，所以就不存在这个问题。因此，WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。只要这些对象在外部消失，它在 WeakSet 里面的引用就会自动消失。

由于上面这个特点，WeakSet 的成员是不适合引用的，因为它会随时消失。另外，由于 WeakSet 内部有多少个成员，取决于垃圾回收机制有没有运行，运行前后很可能成员个数是不一样的，而垃圾回收机制何时运行是不可预测的，因此 ES6 规定 WeakSet 不可遍历。

这些特点同样适用于本章后面要介绍的 WeakMap 结构。

### 语法

WeakSet 是一个构造函数，可以使用`new`命令，创建 WeakSet 数据结构。

```javascript
const ws = new WeakSet();
```

作为构造函数，WeakSet 可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有 Iterable 接口的对象，都可以作为 WeakSet 的参数。）该数组的所有成员，都会自动成为 WeakSet 实例对象的成员。

```javascript
const a = [[1, 2], [3, 4]];
const ws = new WeakSet(a);
// WeakSet {[1, 2], [3, 4]}
```

上面代码中，`a`是一个数组，它有两个成员，也都是数组。将`a`作为 WeakSet 构造函数的参数，`a`的成员会自动成为 WeakSet 的成员。

注意，是`a`数组的成员成为 WeakSet 的成员，而不是`a`数组本身。这意味着，数组的成员只能是对象。

```javascript
const b = [3, 4];
const ws = new WeakSet(b);
// Uncaught TypeError: Invalid value used in weak set(…)
```

上面代码中，数组`b`的成员不是对象，加入 WeakSet 就会报错。

WeakSet 结构有以下三个方法。

- **WeakSet.prototype.add(value)**：向 WeakSet 实例添加一个新成员。
- **WeakSet.prototype.delete(value)**：清除 WeakSet 实例的指定成员。
- **WeakSet.prototype.has(value)**：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。

下面是一个例子。

```javascript
const ws = new WeakSet();
const obj = {};
const foo = {};

ws.add(window);
ws.add(obj);

ws.has(window); // true
ws.has(foo);    // false

ws.delete(window);
ws.has(window);    // false
```

WeakSet 没有`size`属性，没有办法遍历它的成员。

```javascript
ws.size // undefined
ws.forEach // undefined

ws.forEach(function(item){ console.log('WeakSet has ' + item)})
// TypeError: undefined is not a function
```

上面代码试图获取`size`和`forEach`属性，结果都不能成功。

WeakSet 不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet 的一个用处，是储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏。

下面是 WeakSet 的另一个例子。

```javascript
const foos = new WeakSet()
class Foo {
  constructor() {
    foos.add(this)
  }
  method () {
    if (!foos.has(this)) {
      throw new TypeError('Foo.prototype.method 只能在Foo的实例上调用！');
    }
  }
}
```

上面代码保证了`Foo`的实例方法，只能在`Foo`的实例上调用。这里使用 WeakSet 的好处是，`foos`对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑`foos`，也不会出现内存泄漏。

## Map

### 含义和基本用法

JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。

```javascript
const data = {};
const element = document.getElementById('myDiv');

data[element] = 'metadata';
data['[object HTMLDivElement]'] // "metadata"
```

上面代码原意是将一个 DOM 节点作为对象`data`的键，但是由于对象只接受字符串作为键名，所以`element`被自动转为字符串`[object HTMLDivElement]`。

为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。

```javascript
const m = new Map();
const o = {p: 'Hello World'};

m.set(o, 'content')
m.get(o) // "content"

m.has(o) // true
m.delete(o) // true
m.has(o) // false
```

上面代码使用 Map 结构的`set`方法，将对象`o`当作`m`的一个键，然后又使用`get`方法读取这个键，接着使用`delete`方法删除了这个键。

上面的例子展示了如何向 Map 添加成员。作为构造函数，Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。

```javascript
const map = new Map([
  ['name', '张三'],
  ['title', 'Author']
]);

map.size // 2
map.has('name') // true
map.get('name') // "张三"
map.has('title') // true
map.get('title') // "Author"
```

上面代码在新建 Map 实例时，就指定了两个键`name`和`title`。

`Map`构造函数接受数组作为参数，实际上执行的是下面的算法。

```javascript
const items = [
  ['name', '张三'],
  ['title', 'Author']
];

const map = new Map();

items.forEach(
  ([key, value]) => map.set(key, value)
);
```

事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作`Map`构造函数的参数。这就是说，`Set`和`Map`都可以用来生成新的 Map。

```javascript
const set = new Set([
  ['foo', 1],
  ['bar', 2]
]);
const m1 = new Map(set);
m1.get('foo') // 1

const m2 = new Map([['baz', 3]]);
const m3 = new Map(m2);
m3.get('baz') // 3
```

上面代码中，我们分别使用 Set 对象和 Map 对象，当作`Map`构造函数的参数，结果都生成了新的 Map 对象。

如果对同一个键多次赋值，后面的值将覆盖前面的值。

```javascript
const map = new Map();

map
.set(1, 'aaa')
.set(1, 'bbb');

map.get(1) // "bbb"
```

上面代码对键`1`连续赋值两次，后一次的值覆盖前一次的值。

如果读取一个未知的键，则返回`undefined`。

```javascript
new Map().get('asfddfsasadf')
// undefined
```

注意，只有对同一个对象的引用，Map 结构才将其视为同一个键。这一点要非常小心。

```javascript
const map = new Map();

map.set(['a'], 555);
map.get(['a']) // undefined
```

上面代码的`set`和`get`方法，表面是针对同一个键，但实际上这是两个不同的数组实例，内存地址是不一样的，因此`get`方法无法读取该键，返回`undefined`。

同理，同样的值的两个实例，在 Map 结构中被视为两个键。

```javascript
const map = new Map();

const k1 = ['a'];
const k2 = ['a'];

map
.set(k1, 111)
.set(k2, 222);

map.get(k1) // 111
map.get(k2) // 222
```

上面代码中，变量`k1`和`k2`的值是一样的，但是它们在 Map 结构中被视为两个键。

由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。

如果 Map 的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map 将其视为一个键，比如`0`和`-0`就是一个键，布尔值`true`和字符串`true`则是两个不同的键。另外，`undefined`和`null`也是两个不同的键。虽然`NaN`不严格相等于自身，但 Map 将其视为同一个键。

```javascript
let map = new Map();

map.set(-0, 123);
map.get(+0) // 123

map.set(true, 1);
map.set('true', 2);
map.get(true) // 1

map.set(undefined, 3);
map.set(null, 4);
map.get(undefined) // 3

map.set(NaN, 123);
map.get(NaN) // 123
```

### 实例的属性和操作方法

Map 结构的实例有以下属性和操作方法。

**（1）size 属性**

`size`属性返回 Map 结构的成员总数。

```javascript
const map = new Map();
map.set('foo', true);
map.set('bar', false);

map.size // 2
```

**（2）Map.prototype.set(key, value)**

`set`方法设置键名`key`对应的键值为`value`，然后返回整个 Map 结构。如果`key`已经有值，则键值会被更新，否则就新生成该键。

```javascript
const m = new Map();

m.set('edition', 6)        // 键是字符串
m.set(262, 'standard')     // 键是数值
m.set(undefined, 'nah')    // 键是 undefined
```

`set`方法返回的是当前的`Map`对象，因此可以采用链式写法。

```javascript
let map = new Map()
  .set(1, 'a')
  .set(2, 'b')
  .set(3, 'c');
```

**（3）Map.prototype.get(key)**

`get`方法读取`key`对应的键值，如果找不到`key`，返回`undefined`。

```javascript
const m = new Map();

const hello = function() {console.log('hello');};
m.set(hello, 'Hello ES6!') // 键是函数

m.get(hello)  // Hello ES6!
```

**（4）Map.prototype.has(key)**

`has`方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。

```javascript
const m = new Map();

m.set('edition', 6);
m.set(262, 'standard');
m.set(undefined, 'nah');

m.has('edition')     // true
m.has('years')       // false
m.has(262)           // true
m.has(undefined)     // true
```

**（5）Map.prototype.delete(key)**

`delete`方法删除某个键，返回`true`。如果删除失败，返回`false`。

```javascript
const m = new Map();
m.set(undefined, 'nah');
m.has(undefined)     // true

m.delete(undefined)
m.has(undefined)       // false
```

**（6）Map.prototype.clear()**

`clear`方法清除所有成员，没有返回值。

```javascript
let map = new Map();
map.set('foo', true);
map.set('bar', false);

map.size // 2
map.clear()
map.size // 0
```

### 遍历方法

Map 结构原生提供三个遍历器生成函数和一个遍历方法。

- `Map.prototype.keys()`：返回键名的遍历器。
- `Map.prototype.values()`：返回键值的遍历器。
- `Map.prototype.entries()`：返回所有成员的遍历器。
- `Map.prototype.forEach()`：遍历 Map 的所有成员。

需要特别注意的是，Map 的遍历顺序就是插入顺序。

```javascript
const map = new Map([
  ['F', 'no'],
  ['T',  'yes'],
]);

for (let key of map.keys()) {
  console.log(key);
}
// "F"
// "T"

for (let value of map.values()) {
  console.log(value);
}
// "no"
// "yes"

for (let item of map.entries()) {
  console.log(item[0], item[1]);
}
// "F" "no"
// "T" "yes"

// 或者
for (let [key, value] of map.entries()) {
  console.log(key, value);
}
// "F" "no"
// "T" "yes"

// 等同于使用map.entries()
for (let [key, value] of map) {
  console.log(key, value);
}
// "F" "no"
// "T" "yes"
```

上面代码最后的那个例子，表示 Map 结构的默认遍历器接口（`Symbol.iterator`属性），就是`entries`方法。

```javascript
map[Symbol.iterator] === map.entries
// true
```

Map 结构转为数组结构，比较快速的方法是使用扩展运算符（`...`）。

```javascript
const map = new Map([
  [1, 'one'],
  [2, 'two'],
  [3, 'three'],
]);

[...map.keys()]
// [1, 2, 3]

[...map.values()]
// ['one', 'two', 'three']

[...map.entries()]
// [[1,'one'], [2, 'two'], [3, 'three']]

[...map]
// [[1,'one'], [2, 'two'], [3, 'three']]
```

结合数组的`map`方法、`filter`方法，可以实现 Map 的遍历和过滤（Map 本身没有`map`和`filter`方法）。

```javascript
const map0 = new Map()
  .set(1, 'a')
  .set(2, 'b')
  .set(3, 'c');

const map1 = new Map(
  [...map0].filter(([k, v]) => k < 3)
);
// 产生 Map 结构 {1 => 'a', 2 => 'b'}

const map2 = new Map(
  [...map0].map(([k, v]) => [k * 2, '_' + v])
    );
// 产生 Map 结构 {2 => '_a', 4 => '_b', 6 => '_c'}
```

此外，Map 还有一个`forEach`方法，与数组的`forEach`方法类似，也可以实现遍历。

```javascript
map.forEach(function(value, key, map) {
  console.log("Key: %s, Value: %s", key, value);
});
```

`forEach`方法还可以接受第二个参数，用来绑定`this`。

```javascript
const reporter = {
  report: function(key, value) {
    console.log("Key: %s, Value: %s", key, value);
  }
};

map.forEach(function(value, key, map) {
  this.report(key, value);
}, reporter);
```

上面代码中，`forEach`方法的回调函数的`this`，就指向`reporter`。

### 与其他数据结构的互相转换

**（1）Map 转为数组**

前面已经提过，Map 转为数组最方便的方法，就是使用扩展运算符（`...`）。

```javascript
const myMap = new Map()
  .set(true, 7)
  .set({foo: 3}, ['abc']);
[...myMap]
// [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ]
```

**（2）数组 转为 Map**

将数组传入 Map 构造函数，就可以转为 Map。

```javascript
new Map([
  [true, 7],
  [{foo: 3}, ['abc']]
])
// Map {
//   true => 7,
//   Object {foo: 3} => ['abc']
// }
```

**（3）Map 转为对象**

如果所有 Map 的键都是字符串，它可以无损地转为对象。

```javascript
function strMapToObj(strMap) {
  let obj = Object.create(null);
  for (let [k,v] of strMap) {
    obj[k] = v;
  }
  return obj;
}

const myMap = new Map()
  .set('yes', true)
  .set('no', false);
strMapToObj(myMap)
// { yes: true, no: false }
```

如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。

**（4）对象转为 Map**

对象转为 Map 可以通过`Object.entries()`。

```javascript
let obj = {"a":1, "b":2};
let map = new Map(Object.entries(obj));
```

此外，也可以自己实现一个转换函数。

```javascript
function objToStrMap(obj) {
  let strMap = new Map();
  for (let k of Object.keys(obj)) {
    strMap.set(k, obj[k]);
  }
  return strMap;
}

objToStrMap({yes: true, no: false})
// Map {"yes" => true, "no" => false}
```

**（5）Map 转为 JSON**

Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。

```javascript
function strMapToJson(strMap) {
  return JSON.stringify(strMapToObj(strMap));
}

let myMap = new Map().set('yes', true).set('no', false);
strMapToJson(myMap)
// '{"yes":true,"no":false}'
```

另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。

```javascript
function mapToArrayJson(map) {
  return JSON.stringify([...map]);
}

let myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);
mapToArrayJson(myMap)
// '[[true,7],[{"foo":3},["abc"]]]'
```

**（6）JSON 转为 Map**

JSON 转为 Map，正常情况下，所有键名都是字符串。

```javascript
function jsonToStrMap(jsonStr) {
  return objToStrMap(JSON.parse(jsonStr));
}

jsonToStrMap('{"yes": true, "no": false}')
// Map {'yes' => true, 'no' => false}
```

但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。

```javascript
function jsonToMap(jsonStr) {
  return new Map(JSON.parse(jsonStr));
}

jsonToMap('[[true,7],[{"foo":3},["abc"]]]')
// Map {true => 7, Object {foo: 3} => ['abc']}
```

## WeakMap

### 含义

`WeakMap`结构与`Map`结构类似，也是用于生成键值对的集合。

```javascript
// WeakMap 可以使用 set 方法添加成员
const wm1 = new WeakMap();
const key = {foo: 1};
wm1.set(key, 2);
wm1.get(key) // 2

// WeakMap 也可以接受一个数组，
// 作为构造函数的参数
const k1 = [1, 2, 3];
const k2 = [4, 5, 6];
const wm2 = new WeakMap([[k1, 'foo'], [k2, 'bar']]);
wm2.get(k2) // "bar"
```

`WeakMap`与`Map`的区别有两点。

首先，`WeakMap`只接受对象作为键名（`null`除外），不接受其他类型的值作为键名。

```javascript
const map = new WeakMap();
map.set(1, 2)
// TypeError: 1 is not an object!
map.set(Symbol(), 2)
// TypeError: Invalid value used as weak map key
map.set(null, 2)
// TypeError: Invalid value used as weak map key
```

上面代码中，如果将数值`1`和`Symbol`值作为 WeakMap 的键名，都会报错。

其次，`WeakMap`的键名所指向的对象，不计入垃圾回收机制。

`WeakMap`的设计目的在于，有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。请看下面的例子。

```javascript
const e1 = document.getElementById('foo');
const e2 = document.getElementById('bar');
const arr = [
  [e1, 'foo 元素'],
  [e2, 'bar 元素'],
];
```

上面代码中，`e1`和`e2`是两个对象，我们通过`arr`数组对这两个对象添加一些文字说明。这就形成了`arr`对`e1`和`e2`的引用。

一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放`e1`和`e2`占用的内存。

```javascript
// 不需要 e1 和 e2 的时候
// 必须手动删除引用
arr [0] = null;
arr [1] = null;
```

上面这样的写法显然很不方便。一旦忘了写，就会造成内存泄露。

WeakMap 就是为了解决这个问题而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的键名对象和所对应的键值对会自动消失，不用手动删除引用。

基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用`WeakMap`结构。当该 DOM 元素被清除，其所对应的`WeakMap`记录就会自动被移除。

```javascript
const wm = new WeakMap();

const element = document.getElementById('example');

wm.set(element, 'some information');
wm.get(element) // "some information"
```

上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对`element`的引用就是弱引用，不会被计入垃圾回收机制。

也就是说，上面的 DOM 节点对象的引用计数是`1`，而不是`2`。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。

总之，`WeakMap`的专用场合就是，它的键所对应的对象，可能会在将来消失。`WeakMap`结构有助于防止内存泄漏。

注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。

```javascript
const wm = new WeakMap();
let key = {};
let obj = {foo: 1};

wm.set(key, obj);
obj = null;
wm.get(key)
// Object {foo: 1}
```

上面代码中，键值`obj`是正常引用。所以，即使在 WeakMap 外部消除了`obj`的引用，WeakMap 内部的引用依然存在。

### WeakMap 的语法

WeakMap 与 Map 在 API 上的区别主要是两个，一是没有遍历操作（即没有`keys()`、`values()`和`entries()`方法），也没有`size`属性。因为没有办法列出所有键名，某个键名是否存在完全不可预测，跟垃圾回收机制是否运行相关。这一刻可以取到键名，下一刻垃圾回收机制突然运行了，这个键名就没了，为了防止出现不确定性，就统一规定不能取到键名。二是无法清空，即不支持`clear`方法。因此，`WeakMap`只有四个方法可用：`get()`、`set()`、`has()`、`delete()`。

```javascript
const wm = new WeakMap();

// size、forEach、clear 方法都不存在
wm.size // undefined
wm.forEach // undefined
wm.clear // undefined
```

### WeakMap 的示例

WeakMap 的例子很难演示，因为无法观察它里面的引用会自动消失。此时，其他引用都解除了，已经没有引用指向 WeakMap 的键名了，导致无法证实那个键名是不是存在。

贺师俊老师[提示](https://github.com/ruanyf/es6tutorial/issues/362#issuecomment-292109104)，如果引用所指向的值占用特别多的内存，就可以通过 Node 的`process.memoryUsage`方法看出来。根据这个思路，网友[vtxf](https://github.com/ruanyf/es6tutorial/issues/362#issuecomment-292451925)补充了下面的例子。

首先，打开 Node 命令行。

```bash
$ node --expose-gc
```

上面代码中，`--expose-gc`参数表示允许手动执行垃圾回收机制。

然后，执行下面的代码。

```javascript
// 手动执行一次垃圾回收，保证获取的内存使用状态准确
> global.gc();
undefined

// 查看内存占用的初始状态，heapUsed 为 4M 左右
> process.memoryUsage();
{ rss: 21106688,
  heapTotal: 7376896,
  heapUsed: 4153936,
  external: 9059 }

> let wm = new WeakMap();
undefined

// 新建一个变量 key，指向一个 5*1024*1024 的数组
> let key = new Array(5 * 1024 * 1024);
undefined

// 设置 WeakMap 实例的键名，也指向 key 数组
// 这时，key 数组实际被引用了两次，
// 变量 key 引用一次，WeakMap 的键名引用了第二次
// 但是，WeakMap 是弱引用，对于引擎来说，引用计数还是1
> wm.set(key, 1);
WeakMap {}

> global.gc();
undefined

// 这时内存占用 heapUsed 增加到 45M 了
> process.memoryUsage();
{ rss: 67538944,
  heapTotal: 7376896,
  heapUsed: 45782816,
  external: 8945 }

// 清除变量 key 对数组的引用，
// 但没有手动清除 WeakMap 实例的键名对数组的引用
> key = null;
null

// 再次执行垃圾回收
> global.gc();
undefined

// 内存占用 heapUsed 变回 4M 左右，
// 可以看到 WeakMap 的键名引用没有阻止 gc 对内存的回收
> process.memoryUsage();
{ rss: 20639744,
  heapTotal: 8425472,
  heapUsed: 3979792,
  external: 8956 }
```

上面代码中，只要外部的引用消失，WeakMap 内部的引用，就会自动被垃圾回收清除。由此可见，有了 WeakMap 的帮助，解决内存泄漏就会简单很多。

Chrome 浏览器的 Dev Tools 的 Memory 面板，有一个垃圾桶的按钮，可以强制垃圾回收（garbage collect）。这个按钮也能用来观察 WeakMap 里面的引用是否消失。

### WeakMap 的用途

前文说过，WeakMap 应用的典型场合就是 DOM 节点作为键名。下面是一个例子。

```javascript
let myWeakmap = new WeakMap();

myWeakmap.set(
  document.getElementById('logo'),
  {timesClicked: 0})
;

document.getElementById('logo').addEventListener('click', function() {
  let logoData = myWeakmap.get(document.getElementById('logo'));
  logoData.timesClicked++;
}, false);
```

上面代码中，`document.getElementById('logo')`是一个 DOM 节点，每当发生`click`事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是这个节点对象。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。

WeakMap 的另一个用处是部署私有属性。

```javascript
const _counter = new WeakMap();
const _action = new WeakMap();

class Countdown {
  constructor(counter, action) {
    _counter.set(this, counter);
    _action.set(this, action);
  }
  dec() {
    let counter = _counter.get(this);
    if (counter < 1) return;
    counter--;
    _counter.set(this, counter);
    if (counter === 0) {
      _action.get(this)();
    }
  }
}

const c = new Countdown(2, () => console.log('DONE'));

c.dec()
c.dec()
// DONE
```

上面代码中，`Countdown`类的两个内部属性`_counter`和`_action`，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。