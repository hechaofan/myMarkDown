

https://zhuanlan.zhihu.com/p/258619297



https://github.com/attackonryan/Professional-JavaScript-for-Web-Developers-4th-Edition-reading-notes/blob/master/Chapter4.md

 

# 第四章：变量、作用域与内存

## 4.1 原始值与引用值

ECMAScript包含两种不同类型的数据：原始值和引用值。原始值就是最简单的数据，引用值则是由多个值构成的对象。

**保存原始值的变量按值访问，操作的是储存在变量中的实际值**。

**保存引用值的变量是按引用访问的，操作的是对该对象的引用而不是对象本身**。

### 4.1.1 动态属性

略

### 4.1.2 复制值

在把值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在位置。

引用值和原始值的区别在于，**引用值复制的值实际上是一个指针，指向堆内存中的对象**。

所以对同一个指针所指向的对象进行操作，变化会在两个变量中显示出来。

```
let obj1 = new Object()
let obj2 = obj1         // 把指针赋给了obj2
let obj1.name = "ryan"
console.log(obj2.name)  // 因为指向同一个对象，name为"ryan"
```

### 4.1.3 传递参数

**ECMAScript中所有函数的参数都是按值传递的**。

```
function addTen(num){
    num += 10
    return num
}

let count = 20
let result = addTen(count)

console.log(count)    // 20，没有变化
console.log(result)   // 30
```

num实际上是一个局部变量，这个num保存了实参的值，仅仅是一个副本，因此不会影响外部变量。

```
function setName(obj){
    obj.name = "ryan"
}

let person = new Object()

setName(person)
console.log(person.name)    // "ryan"
```

这里的person是一个引用值，obj参数依然遵循按值传递的规则，但是obj是一个指针副本，**因此对指针所指向的对象进行修改，实际上是通过引用进行修改**，变化会表现在外部。

```
function setName(obj){
    obj.name = "ryan"
    obj = new Object()
    obj.name = "Titan"
}

let person = new Object()

setName(person)
console.log(person.name)    // "ryan"
```

现在setName()函数内部会将obj变量重新赋值一个新的对象，但是这个变化不会反应在外部。原因就是，obj实际上只是一个指针副本，覆盖这个指针并不会影响这个指针所指向的对象。

### 4.1.4 确定类型

**typeof**无法区分null或对象。**typeof**虽然对原始值很有用，但它对引用值的作用不大。

为解决这个问题，ECMAScript提供了**instanceof**操作符，语法如下：

```
result = variable instanceof constructor
```

如果变量时给定构造函数的实例，则**instanceof**操作符返回true。

> 所有引用值都是Object的实例，所以通过**instanceof**操作符检测任何引用值和Object构造函数都会返回true

## 4.2 执行上下文与作用域

执行上下文（又称作用域）（以下简称“上下文”）的概念在JavaScript中颇为重要。每个上下文都有一个关联的**变量对象**（variable object)。这个变量对象保存了上下文中所有变量和函数。

全局上下文即是最外层的上下文。浏览器中，全局上下文就是window对象。

每个函数调用都有自己的上下文。当代码执行流进入函数时，函数的上下文被推到一个上下文栈上。函数执行结束，上下文栈会弹出该函数上下文，将控制权返还给之前的执行上下文。

上下文中的代码在执行的时候，会创建变量对象的一个**作用域链**（scope chain)。代码正在执行的上下文的变量对象始终位于作用域的最前端。

如果上下文是函数，则其**活动对象**（activation object）用作变量对象。活动对象最初只有一个定义变量：arguments。作用域链中的下一个变量对象来自包含上下文（上层上下文），以此类推至全局上下文。全局上下文的变量对象始终是最后一个变量对象。

### 4.2.1 作用域链增强

略

### 4.2.2 变量声明

以前var都是声明变量的唯一关键字。ES6增加了let和const两个关键字。

这一节内容，推荐看一下这篇文章[《我用了两个月的时间才理解 let》](https://zhuanlan.zhihu.com/p/28140450)。

## 4.3 垃圾回收

JavaScript通过自动内存管理实现内存分配和闲置资源回收。基本思路很简单：确定哪个变量不会再使用，然后释放它占用的内存。

在浏览器的发展史上，用到过两种主要的标记策略：**标记清理**和**引用计数**。

### 4.3.1 标记清理

**标记清理**（mark-and-sweep）是JavaScript最常用的垃圾回收策略。

垃圾回收程序在运行的时候会给存储在内存中的所有变量都加上标记（标记方法有很多种）。然后，它会去掉上下文中的变量以及被上下文的变量引用的变量的标记。而在此之后仍有标记的变量就是待删除的了，原因是任何在上下文中的变量已经无法访问到这些它们了。

### 4.3.2 引用计数

另一种没那么常用的垃圾回收策略是**引用计数**（reference counting）。其思路是对每个值都记录它被引用的次数。将一个引用值赋给一个变量时，将这个值的引用数加一。当这个变量被其他值覆盖时，这个值的引用数减一。当一个值的引用数为0时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。

引用计数在遇到**循环引用**时不适用，所谓循环引用，就是对象A有一个指针指向对象B，而对象B也引用了对象A。比如：

```
function problem(){
    let objectA = new Object()      // 这里的new Object()值我们叫它a, a的引用数加一
    let objectB = new Object()      // 这里的new Object()值我们叫它b, b的引用数加一
    objectA.b = objectB             // a的引用数再加一
    objectB.a - objectA             // b的引用数再加一
}
```

这里两个对象的引用数都为2，所以永远不会被回收。

由于循环引用问题的存在，Netscape在4.0版放弃了引用计数，转而采用标记清理。

### 4.3.3 性能

略

### 4.3.4 内存管理

分配给浏览器的内存通常比分配给桌面软件的要少很多，因此减少内存占用十分重要。将内存占用量保持在一个较小的值可以让页面性能更好。优化内存占用的最佳手段就是保住在执行代码时只保持必要的数据。

如果数据不再必要，那么把它设置为null，从而释放引用。

```
let globalPerson = new Object()
globalPerson = null      // 解除globalPerson对值的引用
```



